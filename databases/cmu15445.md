# CMU 15-445 notes

### Lecture 1 - Intro to databases

- computers are powerful because they can perform fast and accurate computations on vast amounts of data.

- databases are software which can organize collections of inter-related data that model some aspect of the real world. How do we implement this?

	- flat file database: store relational data as comma seperated values files.
		- inefficient querying if database is too large (have to search line by line)
		- need to parse data for every query
		- how do we deal with duplicates?
		- how do we deal with different threads using the same db file?
		- how do we deal with machine crashes in the middle of updates?
		- what if we the file gets too big for a single machine and we need to split the db per multiple machines?

- A database management system (DBMS) is software that allows creation, querying, updating and administration of databases and takes care of above concerns and more.

- A _data model_ is an abstraction to describe the data living in a database. A _schema_ defines what a certain collection of data looks like.

- Some example data models: relational, key-value, graph, document/object, array/matrix

#### Relational model
- data is abstractly stored as relations
- this data can be accessed using high-level language and DBMS figures out best execution strategy
- the internal storage implementation of data is up to DBMS (tree, index, hash etc.)
- every real-world data entity has _attributes_ which describes the entity. a _relation_ is a set of entities with certain attributes. a _tuple_ is a set of attribute values (or the domain) in the relation.
- n-ary relation = n-column table; tuple = row in relation
- a relation's _primary key_ attribute (or set of attributes) uniquely identifies a single tuple
- a _foregin key_ is a common attribute between different relations that defines relationships between foreign entities of different cardinalites like:
	- one-to-one
	- one-to-many: note that lecturer admits we can just use an array to store the "many" attribute values in the secondary relation which all have the same foregin key found once in the primary relation.
	- many-to-many
- procedural (relational algebra) and non-procedural/declarative (relational calculus) primitives to access/query data inside relations.
- relational algebra operators: SELECT, PROJECTION, UNION, INTERSECTION, DIFFERENCE, PRODUCT, JOIN. The order of operations in a query can affect performance.
- SQL is a declarative de facto standard query language implemenation for relational models.

#### Object/document model
- examples: mongodb, elastic, couchbase, dynamodb
- embed data hierarchy/relations into a single document
- what if we want to query data in the hierarchy from the bottom up?
- example: if we have something like {ARTIST, [ALBUM1, ALBUM2, ALBUM3]}, it is easy to query all the albums of an artist but what if we want to query artists from albums. We would need to replicate the data but with {ALBUM, [ARTIST1, ARTIS2...]} and store both collections. This is a lot of redudant and duplicate data and any changes need to be propagated everywhere.


#### Vector data model
- examples: pinecone, weaviate, marqo, lancedb
- natively stores vectors (1d arrays)
- nearest-neighbor search used to answer queries (instead of exact lookups) and generates ranked list of items (with rank indicating items which are the best match for query)
- used for semantic search on embeddings generated by ml-trained models (chatgpt)

## Lecture 3 - 